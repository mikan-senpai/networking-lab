// Sender


// Header files on IPC and msg have to be included with normal other headers
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/msg.h>
#define MAX_TEXT 512


//We need to create a structure for sending the message and to decide on type of the message
struct my_msg_st {
	long int my_msg_type;	//For message type i.e. from which process to which process
	char some_text[MAX_TEXT];	// The text data that we are going to send
};


//Now come to the main code
int main()
{
	int running = 1;
	struct my_msg_st some_data_bin;	//Making an instance of the structure for binary
	struct my_msg_st some_data_oct; //Making an instance of the structure for octal
	struct my_msg_st some_data_hex; ////Making an instance of the structure for hexadecimal

	int msgid;	// Every message is represented by an id by which we can access the message in the queue
	char buffer[BUFSIZ];
	
	//We need to generate a msgid
	//if successful it will return the msg id through which we can access the queue
	//msgid can be generated by using msgget
	//This system call takes key_t as a parameter
	//This key_t will generate a key which the sender and receiver will agree when they are communicating
	//0666 means r and w permission for owner,group and others
	//IPC_CREATE create the queue if it doesnot already exist
	msgid = msgget((key_t)1234, 0666 | IPC_CREAT);
	
	
	//if not formed it will give error message
	if (msgid == -1) {
		fprintf(stderr, "msgget failed with error: %d\n", errno);
		exit(EXIT_FAILURE);	//exit(1)
	}

	while(running) {
		printf("Enter The Decimal Number : ");	//It will ask you to type the data
		fgets(buffer, BUFSIZ, stdin);

		some_data_bin.my_msg_type = 2;	//it is and agreement between the processes
		some_data_oct.my_msg_type = 8;
		some_data_hex.my_msg_type = 16;
////////////////////////////////////////////////////////////////////////////////////////////////////
		if (strncmp(buffer, "end", 3) != 0)
		{

			//Decimal to Binary
			int num = atoi(buffer);
			long long int bin=0;
			int i=1;
			while (num!=0) {
				int rem = num % 2;
				num /= 2;
				bin += rem * i;
				i *= 10;
			}
			sprintf(some_data_bin.some_text,"%lld",bin); 
			//Now print the message on the screen
			//printf("Binary of %d is : %lld\n", num, bin);
			
			// Decimal to octal
			num = atoi(buffer);
			long long int octal=0;
			i=1;
			while (num!=0) {
				int rem = num % 8;
				num /= 8;
				octal += rem * i;
				i *= 10;
			}
			sprintf(some_data_oct.some_text,"%lld",octal);

			//Decimal to Hexadecimal
			int decimalnum, quotient, remainder;
			char hexadecimalnum[100]="";
			quotient = atoi(buffer);
		
			int j=0;
			
				while (quotient != 0)
				{
					remainder = quotient % 16;
					if (remainder < 10)
						hexadecimalnum[j++] = 48 + remainder;
					else
						hexadecimalnum[j++] = 55 + remainder;
					quotient = quotient / 16;
				}
				strcpy(some_data_hex.some_text,hexadecimalnum);			
		}
		else{
			strcpy(some_data_hex.some_text,buffer);
			strcpy(some_data_bin.some_text,buffer);
			strcpy(some_data_oct.some_text,buffer);
		}

		//strcpy(some_data.some_text, buffer);	//Reading and appending the message
		//strcpy(some_data.some_text, buffer);
		//strcpy(some_data.some_text, buffer);
		//Now we need to send the message
		//we are passing through the msgid, address and size of the msg and
		//we are not going to use any flag,so 4th argument is 0
		//It will fail if an error has been occured
		if (msgsnd(msgid, (void *)&some_data_bin, MAX_TEXT, 0) == -1) {
			fprintf(stderr, "msgsnd failed\n");
			exit(EXIT_FAILURE);
		}


		if (msgsnd(msgid, (void *)&some_data_oct, MAX_TEXT, 0) == -1) {
			fprintf(stderr, "msgsnd failed\n");
			exit(EXIT_FAILURE);
		}

		if (msgsnd(msgid, (void *)&some_data_hex, MAX_TEXT, 0) == -1) {
			fprintf(stderr, "msgsnd failed\n");
			exit(EXIT_FAILURE);
		}



		
		if (strncmp(buffer, "end", 3) == 0) {
			running = 0;
		}
	}

	exit(EXIT_SUCCESS);
}
